1. 양방향 바인딩
=> 데이터(Model)와 UI(View)가 서로 연결되어 있어 한쪽이 변경되면 자동으로 다른 쪽도 반영되는 방식입니다.
=> 일반적으로 v-bind:value="..", v-on:input="" 을 축약한 v-model을 통해 구현합니다.


2. v-on 이벤트 핸들러를 제외하고 Vue의 화면 변경이 발생하면 Vue에 의해 제어한
HTML에 바인딩된 메서드들은 전부 재실행됩니다.
=> 그렇기에 값을 표시할 떄는 메서드를 호출하여 반환된 값으로 반영하는 것이 비효율적입니다.


3. computed
=> Vue가 의존성을 인식하고 의존성 중 하나가 변경된 경우에만 재실행하는 Vue 앱의 프로퍼티입니다.
=> data, methods처럼 Vue App 설정/ 값을 객체를 받습니다.

=> computed 값인 객체는 메서드를 정의하여 사용합니다.
=> 메서드 내부에서 의존성은 data의 값을 의미합니다. 이 data의 값이 변경되었을 때를 감지하여 재실행합니다.
=> 즉, 2의 비효율성을 제어할 수 있습니다.
=> HTML에서 사용할 떄는 메서드지만 프로퍼티처럼 호출하지 않고 그냥 사용합니다.


4. Watcher
=> 의존성 중 하나가 변경될 떄 Vue에 실행하도록 지시할 수 있는 함수입니다.
=> Vue App 설정/ 값을 객체를 받고 내부는 메서드를 정의합니다.
=> data 프로퍼티 이름을 감시자 메서드 이름으로 사용하면 
해당 의존성이 변경될 떄 해당되는 watch가 재실행됩니다.

=> watch 메서드는 인자로 연결된 newValue, oldValue를 받습니다. (this로 접근할 필요가 없습니다.)
=> 값을 반환하지는 않습니다.


5. computed, watch든 반응형 데이터(data)가 변경될 떄만 실행됩니다. (공통점)
=> computed는 결과를 캐싱하여 값이 바뀌지 않으면 다시 계산하지 않습니다.
=> 의존하는 값이 변하지 않으면 실행 x

=> watch는 감시하는 data가 변경될 떄만 실행됩니다.
=> 비동기 처리 사용 가능합니다.

=> 값을 캐시한다가 큰 차이점입니다. console.log(app.count)을 두 번 호출하면 computed는 처음 값과
달라지지 않았음으로 캐시한 값을 내보냅니다. 즉, 부수효과를 일으키기에 적합하지 않습니다. 또한 비동기 처리도
불가능합니다.
=> 또한 computed는 값을 반환하고 watch는 값을 반환하지 않습니다.
=> Vue가 UI를 업데이트 하기에 최적화된 것은 computed입니다.


6. v-bind, v-on 축약어
=> v-on을 @로 축약할 수 있습니다.
=> v-bind을 :으로 축약할 수 있습니다. v-bind:value === :bind=value

